---
# INPUT r_etcd_upgrade_version
# INPUT openshift.common.is_atomic
- name: Verify cluster is healthy pre-upgrade
  # ORIGIN etcdctlv2 etcd_upgrade.vars
  command: "{{ etcdctlv2 }} cluster-health"

- name: Get current image
  # ORIGIN r_etcd_common_service_file etcd_common.vars
  shell: "grep 'ExecStart=' {{ r_etcd_common_service_file }} | awk '{print $NF}'"
  register: current_image

- name: Set new_etcd_image
  set_fact:
    new_etcd_image: "{{ current_image.stdout | regex_replace('/etcd.*$','/etcd:' ~ r_etcd_upgrade_version ) }}"

- name: Pull new etcd image
  command: "docker pull {{ new_etcd_image }}"

- name: Update to latest etcd image
  replace:
    # ORIGIN r_etcd_common_service_file etcd_common.vars
    dest: "{{ r_etcd_common_service_file }}"
    regexp: "{{ current_image.stdout }}$"
    replace: "{{ new_etcd_image }}"

- name: Restart etcd_container
  systemd:
    # ORIGIN r_etcd_common_service etcd_common.vars
    name: "{{ r_etcd_common_service }}"
    daemon_reload: yes
    state: restarted

## TODO: probably should just move this into the backup playbooks, also this
## will fail on atomic host. We need to revisit how to do etcd backups there as
## the container may be newer than etcdctl on the host. Assumes etcd3 obsoletes etcd (7.3.1)
- name: Upgrade etcd for etcdctl when not atomic
  package: name=etcd state=latest
  when: not openshift.common.is_atomic | bool

- name: Verify cluster is healthy
  # ORIGIN etcdctlv2 etcd_upgrade.vars
  command: "{{ etcdctlv2 }} cluster-health"
  register: etcdctl
  until: etcdctl.rc == 0
  retries: 3
  delay: 10

- name: Store new etcd_image
  # DEPENDENCY openshift_facts
  openshift_facts:
    role: etcd
    local_facts:
      etcd_image: "{{ new_etcd_image }}"
